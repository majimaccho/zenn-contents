---
title: "なぜ気軽にテーブルにカラムを足してはいけないのか"
emoji: "🦍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["RDB", "SQL", "DB設計"]
published: false
---

## この記事の想定読者

- DB設計を手探りでしている人

## この記事の目的

データモデリングができていない人によくある兆候である、「気軽にカラムを追加してしまう」ことをなくし、適切にデータモデリング・テーブル設計ができるようになるためのヒントを示すこと。


## はじめに

RDBの設計で何の気なしにテーブルにカラムを追加してしまうことはありませんか？
テーブルの追加よりもアプリケーション側での変更が少ないので、心理的ハードルが低いのかもしれません。

## そもそもデータベース設計がちゃんとできていないことの兆候である

気軽にカラム追加して行き着く先は極端にテーブルのカラム数が多くなることですが、カラムが多すぎるテーブルはDatabase Smellの一つであるとされています。

Refactoring Databases: Evolutionary Database Design
 REFACTORING DATABASES
https://www.oreilly.com/library/view/refactoring-databases-evolutionary/0321293533/


### 正規化ができていない
正規化はDB設計の基本中の基本です。達人に学ぶ（後でちゃんと書く）の第一版のほとんどは正規化について説明されていました。
その正規化ができていないことの代表例であり、カラム追加の最も初歩的な失敗として 「マルチカラムアトリビュート」があります。これは書籍SQLアンチパターンでの呼び名で、列持ちテーブルとも呼ばれます。以下のようなテーブル設計のことを言います。

**連絡先テーブル**
| user_id | phone1 | phone2 | phone3 |
|------|--------|--------|--------|
| 1 | 090-xxxx-xxxx | 080-xxxx-xxxx | NULL   |
| 2 | 070-xxxx-xxxx | NULL   | NULL   |
| 3 | 090-xxxx-xxxx | 050-xxxx-xxxx | 03-xxxx-xxxx |

最初は1つの電話番号しか必要なかったのに、2つ目、3つ目と必要になるたびにカラムを追加してしまった例です。この設計には、
- 特定の電話番号検索するには全てのカラムを検索する必要がある
- 一意性の保証ができない
- 更新時にどのカラムを更新するかのロジックが必要になる
などの問題があります。詳しくはSQLアンチパターンを参照してください。

どのように設計すればよいかというと、電話番号を別テーブルに分割し、1対多の関係を持たせることです。このように設計することで、上記の問題は解決されます。

**連絡先テーブル**
| id | user_id | phone        |
|----|------------|--------------|
| 1  | 1          | 090-xxxx-xxxx |
| 2  | 1          | 080-xxxx-xxxx |
| 3  | 2          | 070-xxxx-xxxx |
| 4  | 3          | 090-xxxx-xxxx |
| 5  | 3          | 050-xxxx-xxxx |
| 6  | 3          | 03-xxxx-xxxx  |


### 複数エンティティの混在

カラムが増えてしまうもう一つの原因として、複数エンティティが混在してしまうことがあります。例えば最初に以下のようなテーブルがあったとします。このテーブルは注文エンティティを表現したテーブルです。

**注文テーブル**
| id | user_id | product_id | order_date |
|----|---------|------------|------------|
| 1  | 1       | 101        | 2024-01-01 |
| 2  | 2       | 102        | 2024-01-02 |
| 3  | 1       | 103        | 2024-01-03 |

今までは注文の情報しか必要なかったところに、画面上に発送日の列だけ足して、入力できるようにしたいという要望が入ったとします。この時に特に考えずユーザー向けの画面同様に、DBのテーブルにもカラムを追加してしまうと以下のようになります。

**注文テーブル**
| id | user_id | product_id | order_date | shipping_date |
|----|---------|------------|------------|---------------|
| 1  | 1       | 101        | 2024-01-01 | 2024-01-05    |
| 2  | 2       | 102        | 2024-01-02 | NULL          |
| 3  | 1       | 103        | 2024-01-03 | NULL          |

この設計は、注文エンティティと発送エンティティの一部が混在してしまっている状態です。発送エンティティが混在しているのであとから発送に関する情報をもっと入れたいとなったときに、ここに追加し続けてしまうことになるでしょう。

よくある失敗パターンとしては安直にフラグxxx_flagとかステータスxxx_statusカラムを追加している例です。これらを追加したくなったときには他のエンティティではないかと疑うようにしましょう。

不安に思ったらまず、楽々ERDレッスンからはじめてみてはいかがでしょうか。

https://amzn.to/47lCVAK

また、DB設計の基本としてエンティティの抜き出しではリソースエンティティとイベントエンティティを抜き出すということがあります。
これについては、kawasimaさんのイミュータブルデータモデルやT字型ER法といった考え方を学ぶと良いでしょう。


## 変更のコストが大きい

リファクタリングのコストがアプリケーションの変更コストを大きく上回る。
本番環境にどういうデータが入っているか分からない。
（今のアプリケーションコードでは入り得ない値が混入することもある）
ダウンタイムがどの程度許容されるか、既存データがどの程度あるか、影響範囲がどの程度あるか、などを考慮する必要がある。
データベースのリファクタリングはアプリケーションのリファクタリングよりもコストが高いことを理解しておく必要があります。
そーだいさんが書いている通り、何よりも覚悟が必要です。気軽に追加したカラムを後から削除するのはとても大変です。


### 移行時に負荷・ロックの発生により長時間のダウンタイムが発生する可能性がある

ALTER TABLEは多くのケースでロックを取ります。レコード数が多いとき、ALTER TABLEの実行時間が長くなり、数時間そのテーブルに対する書き込みができなくなる場合もあります。新テーブルへのINSERTにした場合もレコード数が多い場合、実行時間が長くかかったり、DBのCPUを圧迫する可能性があります。事前にテスト環境でデータ移行のリハーサルを行い、実行時間やDBの負荷を確認しておくことが重要です。
本番環境でデータ移行を実施するときに「postgresql alter table 終わらない」というようなGoogle検索をしてしまうことがないようにしましょう。

![postgresql alter table 終わらない](/images/never-ending-alter-table.png)

ALTER TABLE がどのようなロックを取るかは以下の記事が参考になります。
https://masahikosawada.github.io//2023/05/08/Lock-Levels-Of-ALTER-TABLE/

### Dual Write期間を設ける必要がある可能性がある

データ移行が大規模で、リスクが大きい場合、アプリケーション側で新旧両方のテーブルに書き込みを行うDual Writeを行うと、アプリケーションのロールバックが可能になるので、データ移行のリスクを減らすことができます。しかし、この場合、アプリケーション内部での複雑性が増し、コードの変更にかかるコストが増大します。リリースも複数段階に分けて行う必要があり、スケジュール管理も複雑になります。

### 変更した時よりも時間が経つほど移行のコストは大きくなる

#### 移行自体のコスト

レコード数が大きくなると、上述したロックを取る時間やリソースの逼迫に大きく影響します。

#### 影響範囲を調べるコスト
カラムを別テーブルに移動させる際に、アプリケーションの影響範囲を調査する必要があります。この時、カラムに依存していなくても、テーブルに依存が増えていると、本当にカラムに依存がないかどうかの調査が難しくなります。時間が経つほど、テーブルに対する依存が増えるため、カラムを別テーブルに移動させるコストが増大します。
また、システムとしてどう使われるかは時間の推移とユーザーの増加によって変わりえます。もともと想定していたのとは違う使われ方をしていたり、想定しない値が入っているかもしれません。
ステートレスなWebアプリケーションサーバーの短命なオブジェクトよりもライフサイクルの特定が難しくなりやすいです。特に、昔作成されたレコードについてはさらに難易度が上がります。気がつかないうちに一定期間だけデータ不整合が発生していてデータマイグレーションに、失敗するなんていうこともあるかもしれません。
いずれにしよ、昔からある、膨大なレコードに対しては事前に入念な検証が必要になります。


## インデックスの設計が難しくなる
  - カラムが少ないほどインデックス設計は楽
  - 有効な複合インデックスの設計はそもそも難しい

インデックスは１つのテーブルに対してスキャンする際には1つしか使われません。そのため、複数のカラムに対してインデックスを使った検索を行いたい場合は、複合インデックスを使います。しかし、複合インデックスも全てのカラムにつければいいわけではありません。一般的に複合インデックスは左方一致する条件でしか利用されません。
例えば、以下のようなテーブルとインデックスがあるとします。

**テーブル**

**インデックス**

インデックス定義の左側から一致しているカラムが検索条件に含まれる場合、インデックスは利用されます。

しかし、以下のような検索を行う際にはこのインデックスは利用されません。インデックスの1番左に定義されているカラムが利用されていないからです。

**クエリ**

だからと言ってむやみやたらにインデックスを増やすと更新時のパフォーマンスが大きく劣化します。SQLアンチパターンで説明されているインデックスショットガンという問題です。
むやみにカラムを増やすと後でパフォーマンスチューニングをする際にも足枷になりやすいことがわかります。

---
他の話

## 現実世界の問題

それを追加するといますぐXXX円の売り上げが見込めるし、そうじゃないと目標が未達になる、競合に負けるとかいう話があるかもしれません。もしくはキャッシュアウトして倒産・サービス終了になるかもしれません。そういう場合は、まずはカラムを追加してしまっても良いかもしれません。しかし、その時何を犠牲にしたかを理解しておく必要があります。ビジネスでスピードが求められない時というのは、それ以上成長の見込みが薄い時です。その時には犠牲にした保守性を取り戻すよううなリファクタリングを行う意思決定はされません。コストを投下してもリターンが見込めないからです。