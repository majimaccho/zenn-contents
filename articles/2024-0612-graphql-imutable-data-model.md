---
title: "GraphQLとRDBをつなぐもの"
emoji: "🦍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["GraphQL", "RDB", "SQL"]
published: true
# publication_name: "micin"
---

SORと呼ばれるデータの信頼性が重要で更新や削除の履歴を後から追跡できるようにしなければならないケースでイミュータブルデータモデルが使われる。

RESTFulなAPIではフロントエンド側でインピーダンスミスマッチを解消することになるが、GraphQLではフロントエンド側の問題は解消されている。

しかし、サーバーサイド側ではGraphQLのモデルとRDB上のテーブル構造のミスマッチが発生する。
特に、イミュータブルデータモデルでは

### GraphQLのスキーマ設計
GraphQLはユースケースごとにクエリが定義される

### RDBのテーブル設計
RDBでは事実を正規化して保存する

### GraphQL特有の問題
Graph構造になっているため、各モデルのResolverをナイーブに実装するとモデルからモデルの参照が簡単にN＋1を発生させる
GraphQLはDataLoaderという仕組みを使ってN＋1クエリを1＋1にしているが、DataLoaderはナイーブな実装に比べて複雑なため、実装とテストのコストが高い。
Prismaといった一部のORMとして使われるライブラリにはDataLoaderを内蔵しているものがあり、これらのものを使うと多くのユースケースではDataLoaderの実装コストは無視できるものになる。


### インピーダンスミスマッチ

HasuraやApp Syncでは基本的にGraphQLのモデルとRDBのテーブルが同義に扱われるが、これは望ましい形ではない。

GraphQLのモデルはAPIのクライアントから見たモデルの関係を示す構造になっているべきであり、RDBは事実を信頼性のある形で残すように正規化を行うため、両者を同じ形にすることはクライアントかRDBに問題を押し付ける形になる。

1+1クエリのネストが必要以上に深くなる
クライアント側で必要以上にネストされたデータ構造を扱う必要があり取り回しがわるい

### インピーダンスミスマッチの解消
1. アプリケーションコードで整形する
1. 生のSQLで整形する
1. Viewを使う

### アプリケーションコードで整形する場合
データ形式の整形のコードが大量発生する。
ドメインロジックを含まないただの整形のコードになり、ドメインに集中できなくなる
RDBの責務がアプリケーション側に来てしまう
DataLoaderの実装がしんどい

### 生のSQLで整形する場合
RDBから成形された状態でデータが取得できる
DataLoaderの実装がしんどい

### Viewで整形する場合
一番楽
Prisma等を使ってつるのであればDataLoaderの実装を無視できる

データローダーの実装も普通のAPIの実装よりも取り回しづらくなりがち

ORMを使う場合DBのスキーマとGraphQLのスキーマの差分が大きいとORMを使うメリットを享受できない
prismaのようにデータローダーを内蔵したORMなら尚更

RDBの構造をGraphQLにそのまま露出するのはアンチパターン

### viewが使えないパターン
集計
並び替え
事前に絞り込みができないため

参考

https://zenn.dev/shunjuio/articles/680542da534de5