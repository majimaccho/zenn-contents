---
title: "GraphQLとRDBをつなぐもの"
emoji: "🦍"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["GraphQL", "RDB", "SQL"]
published: true
# publication_name: "micin"
---

## 想定読者

GraphQLでAPIを設計している人

## 読んでどうなって欲しいか

GraphQLとRDBのインピーダンスミスマッチについて理解してもらい、それを解消する方法を知ってもらいたい。
その際にRDBのViewを使うことが有効であることを知ってもらいたい。

## 書かないこと
GraphQLとは何か

## TL;DR

GraphQLのモデルとRDBのテーブルは同じ形にするべきではない。
GraphQLのモデルはAPIのクライアントから見たモデルの関係を示す構造になっているべきであり、RDBは事実を信頼性のある形で残すように正規化を行うため、両者を同じ形にすることはクライアントかRDBに問題を押し付ける形になる。
インピーダンスミスマッチを解消する方法の一つとしてRDBのViewを使うことが有効である。

### GraphQL特有の問題
Graph構造になっているため、各モデルのResolverをナイーブに実装するとモデルからモデルの参照が簡単にN＋1を発生させる
GraphQLはDataLoaderという仕組みを使ってN＋1クエリを1＋1にしているが、DataLoaderはナイーブな実装に比べて複雑なため、実装とテストのコストが高い。
Prismaといった一部のORMとして使われるライブラリにはDataLoaderを内蔵しているものがあり、これらのものを使うと多くのユースケースではDataLoaderの実装コストは無視できるものになる。

### GraphQLとRDBのインピーダンスミスマッチ

HasuraやApp Syncでは基本的にGraphQLのモデルとRDBのテーブルが同義に扱われるが、これは望ましい形ではない。

GraphQLのモデルはAPIのクライアントから見たモデルの関係を示す構造になっているべきであり、RDBは事実を信頼性のある形で残すように正規化を行うため、両者を同じ形にすることはクライアントかRDBに問題を押し付ける形になる。
具体的には以下のような問題が考えられる。
- RDBの正規化が崩れる
- クライアントからは関心のないデータ構造が露出される
- 1+1クエリのネストが必要以上に深くなる
- クライアント側で必要以上にネストされたデータ構造を扱う必要があり取り回しがわるい

### インピーダンスミスマッチの解消
1. アプリケーションコードで整形する
1. 生のSQLで整形する
1. Viewを使う

### アプリケーションコードで整形する場合
データ形式の整形のコードが大量発生する。
ドメインロジックを含まないただの整形のコードになり、ドメインに集中できなくなる
RDBの責務がアプリケーション側に来てしまう
DataLoaderの実装が必要になり、コードが煩雑になる

### 生のSQLで整形する場合
RDBから成形された状態でデータが取得できる
DataLoaderの実装が必要になり、コードが煩雑になる

### Viewで整形する場合
RDBから成形された状態でデータが取得できる
Prisma等を使っているのであればDataLoaderの実装を無視できる

### Viewが使えないパターン
集計
並び替え
事前に絞り込みができないため

参考

https://zenn.dev/shunjuio/articles/680542da534de5